---
title: (1/3) Linear model
author: "Umut Caglar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The Line Fit Function
This is a document invetigates details of linear model 


```{r install packages, echo=FALSE, warning=FALSE, results='hide',message=FALSE}

###*****************************
# INITIAL COMMANDS TO RESET THE SYSTEM
rm(list = ls())
if (is.integer(dev.list())){dev.off()}
cat("\014")
seedNo=14159
set.seed(seedNo)
###*****************************

###*****************************
require("sicegar")
require("dplyr")
require("ggplot2")
###*****************************
```

## Data generation
To simulate the results, we will go backwards and firstly generate some data to analyze. To add some randomness to the input data I will use some noise. The input of all package must be in the form of a data frame with at least 2 columns time and intensity. 

`sicegar::lineFitFormula` generate a set of intensity values based on time, slope and intersection values supplied. So here we are generating a set of points that are on a line with a slope of 4 which intersects with x axis at -2.

```{r generate data}
time=seq(3,24,0.5)

#intensity with Noise
noise_parameter=7
intensity_noise=stats::runif(n = length(time),min = 0,max = 1)*noise_parameter
intensity=sicegar::lineFitFormula(time, slope=4, intersection=-2)
intensity=intensity+intensity_noise

dataInput=data.frame(intensity=intensity,time=time)
```

## Data normalization 

This is the first step. Data should be normalized before any fit. I.e time and intensity should be in between 0-1 interval. 

There is a nuance 

*  Time is normalized with respect to maximum value the time parameter takes.
```{r time normalization, eval=FALSE}
timeRatio=max(timeData); timeData=timeData/timeRatio
```

*  Intensity is normalized with respect to intensity interval
```{r intensity normalization, eval=FALSE}
intensityMin = min(dataInput$intensity)
intensityMax = max(dataInput$intensity)
intensityRatio = intensityMax - intensityMin

intensityData=dataInput$intensity-intensityMin
intensityData=intensityData/intensityRatio
```

The normalization code is 

```{r normalize_data}
normalizedInput = sicegar::normalizeData(dataInput = dataInput, 
                                         dataInputName = "Sample001")
```


Components of the normalization output

```{r normalized_data_output}
head(normalizedInput$timeIntensityData) # the normalized time and intensity data
print(normalizedInput$dataScalingParameters) # the normalization parameters that is needed to go back to original scale
print(normalizedInput$dataInputName) # a useful feature to track the sample in all the process
```


## The figures of raw and normalized datasets

```{r plot raw and normal data, echo=FALSE, fig.height=4, fig.width=8}
dataInput %>% dplyr::mutate(process="raw")->dataInput2
normalizedInput$timeIntensityData %>%
  dplyr::mutate(process="normalized")->timeIntensityData2
dplyr::bind_rows(dataInput2,timeIntensityData2) -> combined
combined$process <- factor(combined$process, levels = c("raw","normalized"))

ggplot2::ggplot(combined,aes(x=time, y=intensity))+
  ggplot2::facet_wrap(~process, scales = "free")+
  ggplot2::geom_point()
```

## Line fit of the data

Now it is time to calculate the parameters by using `sicegar::lineFitFunction()`

```{r linefit_data}
parameterVector<-sicegar::lineFitFunction(dataInput = normalizedInput, tryCounter = 2)

# Where tryCounter is a tool usually provided by sicegar::fitFunction when the sicegar::lineFitFunction is called from sicegar::fitFunction. 

# If tryCounter==1 it took the  start position given by sicegar::fitFunction
# If tryCounter!=1 it generates a random start position from given interval
```

the function outputs a vector that gives information about multiple parameters

```{r parameter vector}
print(t(parameterVector))
```

Here is the brief explanations of the parameters that are given by `sicegar::lineFitFunction` (In different order then than the output vector of the `sicegar::lineFitFunction`)

These are the parameters of the normalization step:

* `dataScalingParameters.timeRatio`: Maximum of raw time data       
* `dataScalingParameters.intensityMin`: Minimum of raw intensity data
* `dataScalingParameters.intensityMax`: Maximum of raw intensity data
* `dataScalingParameters.intensityRatio`: Maximum - Minimum of intensity data

They are the meta summary of the result parameters

* `model`: Gives the used model for fitting
* `isThisaFit`: FALSE means there is not any successful fit. TRUE means there is at least one successful fit 

Likelihood maximization algorithm starts from a random initiation point (if tryCounter!=1) and goes down the fitness space by a gradient decent algorithm. These parameters represent the start point of the gradient decent algorithm.

* `startVector.slope`: Slope value of the initiation point
* `startVector.intersection`: Intersection value of the initiation point

For each parameter that needs to fitted by LM algorithm; the algorithm gives a bunch of statistical parameters; including the estimated value of the parameter. __Note: They are for normalized data.__


They are the parameters associated with parameter "slope"

* `slope_N_Estimate`: here N stand for the slope in the normalized scale
* `slope_Std_Error`
* `slope_t_value`    
* `slope_Pr_t`

They are the parameters associated with parameter "intersection"

* `intersection_N_Estimate`  here N stand for the intersection in the normalized scale
* `intersection_Std_Error`  
* `intersection_t_value`  
* `intersection_Pr_t` 


Here are the fit-parameters that are not related with individual variable that is fitted, but gives information about overal fit.

They are the parameters associated with the quality of the fit. 

* `residual_Sum_of_Squares`: Small value indicate better fit
* `log_likelihood`: Higher value indicate a better fit
* `AIC_value`: Smaller value indicate a better fit
* `BIC_value`: Smaller value indicate a better fit

Final results that are relavent to most of the users   

They are the fitted values after converting everything from normalized to un-normalized scale.

* `intersection_Estimate`: Intersection estimate for the raw data
* `slope_Estimate`: Slope estimate for the raw data


## Check the results to see if the results are meaningfull

By using the `intersection_Estimate`, `slope_Estimate` parameters of the linefit and the time sequence that we already created we can calculate the intensity values by the help of `sicegar::lineFitFormula()`. We can draw the best line on top of our initial data.

```{r plot raw data and fit, fig.height=4, fig.width=8}
intensityTheoretical=sicegar::lineFitFormula(time,
                                             slope=parameterVector$slope_Estimate,
                                             intersection=parameterVector$intersection_Estimate)
comparisonData=cbind(dataInput,intensityTheoretical)

ggplot2::ggplot(comparisonData)+
  ggplot2::geom_point(aes(x=time, y=intensity))+
  ggplot2::geom_line(aes(x=time,y=intensityTheoretical))+
  ggplot2::expand_limits(x = 0, y = 0)
```
