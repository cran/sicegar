---
title: (3/3) Double Sigmoidal model
author: "Umut Caglar"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# The Double Sigmoidal Fit Function
This is a document invetigates details of double sigmoidal model 


```{r install packages, echo=FALSE, warning=FALSE, results='hide',message=FALSE}

###*****************************
# INITIAL COMMANDS TO RESET THE SYSTEM
rm(list = ls())
if (is.integer(dev.list())){dev.off()}
cat("\014")
seedNo=14159
set.seed(seedNo)
###*****************************

###*****************************
require("sicegar")
require("dplyr")
require("ggplot2")
###*****************************
```

## Data generation
To simulate the results, we will go backwards and firstly generate some data to analize. To add some randomness to the input data I will use some noise. The input of all package must be in the form of a data frame with at least 2 columns time and intensity. 

`sicegar::doublesigmoidalFitFormula` generate a set of intensity values based on finalAsymptoteIntensity, maximum, slope1, midPoint1,slope2, midPointDistance values supplied. So here we are generating a set of points that are on two sigmoidals glued side by side from the maximum of the combined function.

note that slope1, slope2 and finalAsymptoteIntensity are not exactly the exacly slope1 slope2 and final asymtote intensity of the final function. they are parameters related with them.

```{r generate data}
time=seq(3,24,0.5)

#simulate intensity data and add noise
noise_parameter=0.1
intensity_noise=stats::runif(n = length(time),min = 0,max = 1)*noise_parameter
intensity=doublesigmoidalFitFormula(time,
                                    finalAsymptoteIntensity=.3,
                                    maximum=4,
                                    slope1=1,
                                    midPoint1=7,
                                    slope2=1,
                                    midPointDistance=8)
intensity=intensity+intensity_noise

dataInput=data.frame(intensity=intensity,time=time)
```

## Data normalization 

This is the first step. Data should be normalized before any fit. I.e time and intensity should be in between 0-1 interval. 

There is a nuance 

*  Time is normalized with respect to maximum value the time parameter takes.
```{r time normalization, eval=FALSE}
timeRatio=max(timeData); timeData=timeData/timeRatio
```

*  Intensity is normalized with respect to intensity interval
```{r intensity normalization, eval=FALSE}
intensityMin = min(dataInput$intensity)
intensityMax = max(dataInput$intensity)
intensityRatio = intensityMax - intensityMin

intensityData=dataInput$intensity-intensityMin
intensityData=intensityData/intensityRatio
```

The normalization code is 

```{r normalize_data}
normalizedInput = sicegar::normalizeData(dataInput = dataInput, 
                                         dataInputName = "Sample001")
```


Components of the normalization output

```{r normalized_data_output}
head(normalizedInput$timeIntensityData) # the normalized time and intensity data
print(normalizedInput$dataScalingParameters) # the normalization parameters that is needed to go back to original scale
print(normalizedInput$dataInputName) # a useful feature to track the sample in all the process
```


## The figures of raw and normalized datasets

```{r plot raw and normal data, echo=FALSE, fig.height=4, fig.width=8}
dataInput %>% dplyr::mutate(process="raw")->dataInput2
normalizedInput$timeIntensityData %>%
  dplyr::mutate(process="normalized")->timeIntensityData2
dplyr::bind_rows(dataInput2,timeIntensityData2) -> combined
combined$process <- factor(combined$process, levels = c("raw","normalized"))

ggplot2::ggplot(combined,aes(x=time, y=intensity))+
  ggplot2::facet_wrap(~process, scales = "free")+
  ggplot2::geom_point()
```

## Double-Sigmoidal fit of the data

Now it is time to calculate the parameters by using `sicegar::doublesigmoidalFitFunction()`

```{r doublesigmoidalfit_data}
parameterVector<-sicegar::doublesigmoidalFitFunction(normalizedInput,tryCounter=2)

# Where tryCounter is a tool usually provided by sicegar::fitFunction when the sicegar::sigmoidalFitFunction is called from sicegar::fitFunction. 

# If tryCounter==1 it took the  start position given by sicegar::fitFunction
# If tryCounter!=1 it generates a random start position from given interval
```

the function outputs a vector that gives information about multiple parameters

```{r parameter vector}
print(t(parameterVector))
```

Here is the brief explanations of the parameters that are given by `sicegar::doublesigmoidalFitFunction` (In different order then than the output vector of the doublesigmoidalFitFunction)

These are the parameters of the normalization step

* `dataScalingParameters.timeRatio`: Maximum of raw time data       
* `dataScalingParameters.intensityMin`: Minimum of raw intensity data
* `dataScalingParameters.intensityMax`: Maximum of raw intensity data
* `dataScalingParameters.intensityRatio`: Maximum - Minimum of intensity data

They are the meta summary of the result parameters

* `isThisaFit`
* `model`
* `numericalParameters`: __"FALSE"__ in this case  

Likelihood maximization algorithm starts from a random initiation (if tryCounter!=1) point and goes down the fitness space by a gradient decent algorithm. these parameters represent the start point of the gradient decent algorithm.

* `startVector.maximum`: maximum value of initiation point
* `startVector.slope1`: slope1 value of initiation point
* `startVector.midPoint1`: midPoint1 value of initiation point
* `startVector.slope2`: slope2 value of initiation point
* `startVector.midPointDistance`: midPointDistance value of initiation point
* `startVector.finalAsymptoteIntensity`: finalAsymptoteIntensity value of initiation point.

For each parameter that needs to fitted by LM algorithm; the algorithm gives a bunch of statistical parameters; including the estimated value of the parameter

They are the parameters associated with parameter “maximum”

* `maximum_N_Estimate`: Here N stand for the intersection in the normalized scale
* `maximum_Std_Error`
* `maximum_t_value`
* `maximum_Pr_t`

They are the parameters associated with parameter “slope1” 

* `slope1_N_Estimate`: Here N stand for the intersection in the normalized scale
* `slope1_Std_Error`
* `slope1_t_value`
* `slope1_Pr_t`

They are the parameters associated with parameter “midPoint1” 

* `midPoint1_N_Estimate`: Here N stand for the intersection in the normalized scale
* `midPoint1_Std_Error`
* `midPoint1_t_value`
* `midPoint1_Pr_t`

They are the parameters associated with parameter “slope2” 

* `slope2_N_Estimate`: Here N stand for the intersection in the normalized scale
* `slope2_Std_Error`
* `slope2_t_value`
* `slope2_Pr_t`


They are the parameters associated with parameter “midPointDistance” 

* `midPointDistance_N_Estimate`: Here N stand for the intersection in the normalized scale 
* `midPointDistance_Std_Error`
* `midPointDistance_t_value`
* `midPointDistance_Pr_t`

They are the parameters associated with parameter “finalAsymptoteIntensity” 

* `finalAsymptoteIntensity_N_Estimate`: Here N stand for the intersection in the normalized scale  
* `finalAsymptoteIntensity_Std_Error`
* `finalAsymptoteIntensity_t_value`
* `finalAsymptoteIntensity_Pr_t`

They are the parameters associated with the quality of the fit.

* `residual_Sum_of_Squares`: Small value indicate better fit
* `log_likelihood`: Higher value indicate a better fit
* `AIC_value`: Smaller value indicate a better fit
* `BIC_value`: Smaller value indicate a better fit

They are the fitted values after converting everything from normalized to un-normalized scale. (Without numeric correction)

* `maximum_Estimate`: Maximum intensity estimate for the raw data
* `slope1_Estimate`: __Slope1 parameter__ estimate for the raw data 
* `midPoint1_Estimate`: Mid-point 1 estimate (time the intensity reaches 1/2 of maximum) for the raw data. _Needs numerical correction_
* `slope2_Estimate`: __Slope2 parameter__ estimate for the raw data 
* `midPointDistance_Estimate`: Distance between mid- point 1 and mid-point 2. Where mid-point 2 is the time that intensity decreases to the value in between final asymptote intensity and maximum value. _Needs numerical correction_
* `finalAsymptoteIntensity_Estimate`: This is the __ratio__ between asymptote intensity and maximum value of the function.

## Check the results to see if the results are meaningfull

By using the `maximum_Estimate`, `slope_Estimate`, `midPoint_Estimate` parameters of the sigmoidalfit and the time sequence that we already created we can calculate the intensity values by the help of `sicegar::sigmoidalFitFormula()`. We can draw the best sigmoidal fit on top of our initial data.

```{r plot raw data and fit, fig.height=4, fig.width=8}
intensityTheoretical=
  sicegar::doublesigmoidalFitFormula(
    time,
    finalAsymptoteIntensity=parameterVector$finalAsymptoteIntensity_Estimate,
    maximum=parameterVector$maximum_Estimate,
    slope1=parameterVector$slope1_Estimate,
    midPoint1=parameterVector$midPoint1_Estimate,
    slope2=parameterVector$slope2_Estimate,
    midPointDistance=parameterVector$midPointDistance_Estimate)

comparisonData=cbind(dataInput,intensityTheoretical)

require(ggplot2)
ggplot2::ggplot(comparisonData)+
  ggplot2::geom_point(aes(x=time, y=intensity))+
  ggplot2::geom_line(aes(x=time,y=intensityTheoretical), colour="orange")+
  ggplot2::expand_limits(x = 0, y = 0)
```
